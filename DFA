!pip install mne

import mne  
import matplotlib.pyplot as plt
import numpy as np
import math

raw = mne.io.read_raw_eeglab(r'LS_10_4.set',preload=True) #Program needs .set and .fdt files with same name

raw.set_channel_types({'Cz': 'eeg'}) #sets Cz and EEG 

raw.set_eeg_reference(ref_channels=['Cz']) 

print(raw.ch_names)

data,times=raw[:]
ds=data.shape
ts=times.shape
print("Size of data: ",ds)
print("Size of times: ",ts)
plt.plot(times[:],data[0, :]*1000000) #convert to microvolts
plt.title("EEG Data - Channel 1")
plt.xlabel("Time[s]")
plt.ylabel("Amplitude [Î¼V]")
plt.show()

#MATLAB CODE 1

RW=np.cumsum(data-np.mean(data))


#MATLAB CODE 2

RMS=math.sqrt((np.mean(data))**2)

#MATLAB CODE 3
#This should closely match the paper...

X=np.cumsum(data-np.mean(data))
X=X.T
scale=1024
m=1

segments=len(X)//scale #// is integer division
fit=[]
RMS=[]

for i in range(segments):
    Idx_start = i * scale #Adjust scale for valid Python indexing
    Idx_stop = (i + 1) * scale
    
    Index = np.arange(Idx_start, Idx_stop)
    X_Idx = X[Idx_start:Idx_stop]

    C1=np.polyfit(Index, X_Idx, m)
    
    fit_segment = np.polyval(C, Index)  # Compute fitted values
    fit.append(fit_segment)
    RMS.append(np.sqrt(np.mean((X_Idx - fit_segment) ** 2)))

F=np.sqrt(np.mean(RMS)**2)


#MATLAB CODE 5

X=np.cumsum(data-np.mean(data))
X=X.T
scale=[16,32,64,128,256,512,1024]
m=1

fit=[]
RMS=[]
segments=[]
F = np.zeros(len(scale))
segment_RMS=[]

for j in range(len(scale)):
    segment=np.floor(len(X)/scale[j])
    segments.append(segment)

    Index = np.empty((int(segment), scale[j]), dtype=int)
    
    for i in range(len(segments)):
        Idx_start = i * scale[j] #Adjust scale for valid Python indexing
        Idx_stop = (i + 1) * scale[j]
        
        Index[i,:] = np.arange(Idx_start, Idx_stop)
        X_Idx = X[Index[i,:]]

        C1=np.polyfit(Index[i,:], X_Idx, m)
    
        fit_segment = np.polyval(C, Index)  # Compute fitted values
        fit.append(fit_segment)
        #RMS.append(np.sqrt(np.mean((X_Idx - fit_segment) ** 2)))

        rms_value = np.sqrt(np.mean((X_Idx - fit_segment) ** 2))
        segment_RMS.append(rms_value)

    F[j] = np.sqrt(np.mean(np.array(segment_RMS) ** 2))

for k in range(len(scale)):
    C2=np.polyfit(np.log2(scale),np.log2(F),1)
    H=C2[0]
    RegLine=np.polyval(C2,np.log2(scale))
print(RegLine)
#H currently looks like Brownian noise...

x=np.linspace(0,100,7)
y=RegLine

plt.plot(x,y)
